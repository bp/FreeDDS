<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Data Dictionary System: Developers "C" Templates (Template 1)</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <meta name="keywords" 
      content="Data Dictionary System Free Seismic Processing System">
    <link href="../../styles.css" type="text/css" rel="stylesheet">
    <script src="../../javascript.js" language="JavaScript"
      type="text/javascript"></script>
    <script type="text/javascript">
      if (location.search.search("remove=") >= 0) {
         var tmp = "position:absolute;left:-9999px;";
      } else {
         var tmp = "";
      }
      document.write("<style type='text/css'>.comment "
         +"{color:#c00000;"+tmp+"}<\/style>");

      function setRemoveOption() {
         var tmp;
         if (location.search.search("remove=") >= 0) {
            tmp = "'Add Tutorial Comments'";
         } else {
            tmp = "'Remove Tutorial Comments'";
         }
         document.write("<center><form><input type='button' value="
            +tmp+" onclick='toggleComments();'><\/form><\/center>");
      }      
         
      function toggleComments() {
         if (location.search.search("remove=") >= 0) {
            document.location.search = "";
         } else {
            location = "?remove=";
         }
      }
    </script>
    <style type="text/css">
      pre {color:#000000;}
    </style>  
  </head>
  <body>
    <script type="text/javascript">
      header("developers","ctemplates","c_template1")
    </script>
    <!*********************************************************************>

    <script type="text/javascript">setRemoveOption();</script>

    <pre>
/***********************************************************************
                   B P   A M E R I C A  
           PROPRIETARY - TO BE MAINTAINED IN CONFIDENCE 
                         COPYRIGHTED 2006
 ***********************************************************************

                           TEMPLATE 1

     <b>"C" template demonstrating the use of the base dds routines</b>
     <b>for a simple trace-to-trace processing scheme.</b>

     Written by Jerry Ehlers November 2006

 **********************************************************************/

#define _POSIX_SOURCE 1    /* Check POSIX Standard            */
#define ANSI               /* Turn on prototyping from cdds.h */

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
<span class="comment">/*
   INCLUDE THE DDS API (Application Program Interface)
 */</span>
#include &lt;cdds.h&gt;           /* "C" dds include */

#define RCSID "$Id: c_template1.html 1 2009-01-06 00:31:13Z ehlersjw $"
#define TITLE "template1: C template using DDS base routines"

void doit(int, int, int, int, int, int, int, float, float*, float*);
void help();

/***********************************************************************
 *
 * main
 *
 **********************************************************************/
int main(int argc, char **argv)
{
   BIN_TAG in_bin=-1, in_buf_bin=-1, out_buf_bin=-1, out_bin=-1;
   const char *in_dict, *in_buf_dict, *out_buf_dict, *out_dict;
   int ier, ns, nout, tag, ndxsmp, nbytes;
   float scale, *inbuf, *outbuf;
   char *prog;

   /***********************************************************************
    *    initialize
    **********************************************************************/
   /*
    * get the program name
    */
   prog = strrchr(argv[0], '/');
   if (prog) prog++;
   else prog = argv[0];

   /*
    * pass the command line arguments on to DDS
    */
   setargcv(argc, argv);
   <span class="comment">/*
      OPEN THE PRINT FILE &amp; CHECK FOR HELP 
      'cdds_openpr' function:
           Open a printfile using the information automatically 
           generated by RCS in '$Id: c_template1.html 1 2009-01-06 00:31:13Z ehlersjw $'.  If the user specifies some
           form of help (-h help= HELP=...) on the command line,
           then the return value will be &lt; 0.
    */</span>
   ier = <a href="../capi/openpr.html">cdds_openpr</a>(prog, RCSID);
   if (ier &gt; 0) help();

   /***********************************************************************
    *    open input data file
    **********************************************************************/
   <span class="comment">/*    
      OPEN THE INPUT DICTIONARY 
      'cdds_in' function:
           This function opens an input dictionary.
    */</span>
   in_dict = <a href="../capi/in.html">cdds_in</a>("in", "stdin:", TITLE);
   <span class="comment">/*
      OPEN THE INPUT BINARY 
      'cdds_open' function:
           This function opens the input binary.
    */</span>
   in_bin = <a href="../capi/open.html">cdds_open</a>(in_dict, "in_format", "in_data", "r");
   <span class="comment">/*
      PRINT ERROR MESSAGE
      'cdds_prterr' function:
           Print an error message to the console (&amp; printfile if 
           exists). Error count is kept by DDS.  Check for errors later,  
           before processing to check for as many things as possible first.
    */</span>
   if (in_bin &lt; 0) {
      <a href="../capi/prterr.html">cdds_prterr</a>("Unable to open input data\n");
   }
   <span class="comment">/*
      RETRIEVE DATASET DEFINITIONS NEEDED BY APPLICATION 
      'cdds_scanf' function:
           Default values are assigned prior to definition retrieval.
           A variable are unchanged, if it is not specified.

           NOTE: What's special about the "size.axis(1)" definition?
           'axis(N)' is automatically converted to the Nth axis name.
           This allows hyper cube attributes to be retrieved by axis
           number, instead of axis name.  For example, "size.axis(1)"
           becomes "size.t" (assuming "axis=  t x y").

           WARNING: Do NOT use %i, use %d to scan for integers because
                    %i will interpret a value with a leading "0" as 
                    octal instead decimal (eg. 010 would be read as
                    8 instead of 10).
    */</span>
   /*
    *    Get input data parameters
    */
   <a href="../capi/scanf.html">cdds_scanf</a>("size.axis(1)", "%d", &amp;ns);
      
   /***********************************************************************
    *    open input data buffer
    **********************************************************************/
   /*
    *      Define the input buffer Samples as host-dependent float
    */
   <span class="comment">/*
      SETUP INTERNAL BUFFER REDEFINING Samples
      'cdds_dict' function:
           Setup to print definitions to the internal "override:"
           dictionary.

      'cdds_printf' function:
           Define SAMPLE_TYPE as host-dependent floats
    */</span>
   <a href="../capi/dict.html">cdds_dict</a>("override:", "print");
   <a href="../capi/printf.html">cdds_printf</a>("fmt:*:ibuf.SAMPLE_TYPE", "\n");
   <a href="../capi/printf.html">cdds_printf</a>(" ", "   typedef float SAMPLE_TYPE;\n");    
   <span class="comment">/*
      OPEN THE INTERNAL BUFFER
      'cdds_out' function:
           Opens the internal buffer for writing into.  

      Add aliased old_format to point to the input format so that 
      it will be used as the default output format.

      Setup internal buffer format to be "asp" via "ibuf_fmt" alias

      Open the binary for the internal buffer via "cdds_open"

    */</span>
   in_buf_dict = <a href="../capi/out.html">cdds_out</a>("ibuf", " ", in_dict);
   <a href="../capi/printf.html">cdds_printf</a>("$old_format", "format\n");
   <a href="../capi/printf.html">cdds_printf</a>("ibuf_fmt", "asp\n");
   in_buf_bin = <a href="../capi/open.html">cdds_open</a>(in_buf_dict, "ibuf_fmt", " ", "m");
   if (in_buf_bin &lt; 0) {
      <a href="../capi/prterr.html">cdds_prterr</a>("Unable to open internal input buffer!\n");
   }
   <span class="comment">/*
      INITIALIZE MAPPING FROM INPUT TO INTERNAL BUFFER
      'cdds_openm' function:
           Opens the mapping function from <b>in_bin</b> to <b>in_buf_bin</b>.
           This is NOT necessary -- DDS will make this call for you the
           first time you try and map data from in_bin to in_buf_bin. 
           However, the dictionaries must still be opened at the time.
           It is best, in general, to keep the dictionaries opened
           anyway and let the <b>cdds_close</b> close them at the time
           of the binary closing.
    */</span>
   <a href="../capi/openm.html">cdds_openm</a>(in_buf_bin, 0, in_bin, 0);

   /***********************************************************************
    *    read parameters
    **********************************************************************/
   <span class="comment">/*
      RETRIEVE COMMAND LINE PARAMETERS
      'cdds_dict' function:
           'cdds_dict' selects the 'par:' dictionary for scanning.
           This dictionary only contains definitions from the command
           line, and parameter dictionaries ("par=  fn1  fn2 ...").
           Parameters ("in= ", "out_format= ", etc.) for the current
           process can be read, without ambiguity from the input history 
           (ie. local parameters only).
    */</span>
   <a href="../capi/dict.html">cdds_dict</a>("par:", "scan");

   /*
    * get scale parameter (default 1.0)
    */
   scale = 1.0;
   <a href="../.capi/scanf.html">cdds_scanf</a>("scale", "%f", &amp;scale);

   /*
    * get # samples out (default ns)
    */
   <span class="comment">/*
      Use "%d" instead of "%i" because "%i" will read any values
      starting with "0" as octal numbers instead of decimal numbers.
    */</span>
   nout = ns;
   <a href="../.capi/scanf.html">cdds_scanf</a>("nout", "%d", &amp;nout);

   /***********************************************************************
    *    print user parameters
    **********************************************************************/
   <span class="comment">/*
      PRINT MESSAGES 
      'cdds_prtmsg' function:
           This function prints a formatted message to the print file
           opened by "cdds_openpr"; otherwise to the console (stderr).

      'cdds_prtcon' function:
           This function prints a formatted message to the console and
           to the print file if opened.
   
      'cdds_prtmsg' function:
           This function prints a formatted error message to the console 
           and to the print file if opened.  It also keeps track of the
           number of error messages printed for "cdds_closepr".
    */</span>
   <a href="../capi/prtmsg.html">cdds_prtmsg</a>("\n*** USER PARAMETERS ***\n\n");
   <a href="../capi/prtmsg.html">cdds_prtmsg</a>("\tscale = %g\n", scale);
   <a href="../capi/prtmsg.html">cdds_prtmsg</a>("\tnout  = %d\n", nout);
   <a href="../capi/prtmsg.html">cdds_prtmsg</a>("\n");

   /*
    * Check parameters
    */
   if (scale &lt; 0.0) {
      <a href="../capi/prtcon.html">cdds_prtcon</a>("WARNING: \"scale\" is negative!\n");
   }

   /***********************************************************************
    *    allocate dynamic arrays
    **********************************************************************/
   <span class="comment">/*
      Don't allocate arrays if there are already any errors; 
      we could have bad array sizes
    */</span> 
   if (cdds_errors()) goto finish;
   <span class="comment">/*
      ALLOCATE DYNAMIC ARRAYS 
      'cdds_prec' function:
           This function returns the number of bytes for each trace in
           an open binary.

      'cdds_malloc' function:
           This function allocates memory or reports an error &amp; aborts.
           Storage can be released by calling "cdds_free".  Use 
           "dds_debug= dbg_call" will cause DDS to check memory at
           each api call.

      'cdds_member' function:
           This function gets the field tag for any trace header in a
           given opened binary; the 2nd parameter, "0", specifies
           the trace sequence; the 3rd parameter specifies the name
           of the trace header -- in this case it's for "Samples".

      'cdds_index' function:
           This function gets the offset index to a trace field.
   */</span>
   /*
    * Allocate memory for an entire input record &amp; single output trace 
    */
   nbytes = <a href="../capi/prec.html">cdds_prec</a>(in_buf_bin, 0);
   inbuf = <a href="../capi/malloc.html">cdds_malloc</a>(nbytes);

   nbytes = <a href="../capi/prec.html">cdds_prec</a>(out_buf_bin, 0);
   outbuf = <a href="../capi/malloc.html">cdds_malloc</a>(nbytes);

   /*
    * get index to samples (allowing for possible trace headers)
    * (since we are not modifying any trace headers in this program,
    *  we can use the same index for both input and output buffers.)
    */
   tag = <a href="../capi/member.html">cdds_member</a>(in_buf_bin, 0, "Samples");
   ndxsmp = <a href="../capi/index.html">cdds_index</a>(in_buf_bin, tag, DDS_FLOAT);

   /***********************************************************************
    *    open internal output buffer
    **********************************************************************/
   <span class="comment">/*
      CHECK FOR ERRORS BEFORE PROCEEDING ANY FURTHER 
      'cdds_errors' function:
           This function returns the number of errors reported using
           "cdds_prterr".  No reason to create a new output if there
           have been any errors.
    */</span>
   if (<a href="../capi/errors.html">cdds_errors</a>()) goto finish;
   <span class="comment">/*
      CREATE OUTPUT INTERNAL BUFFER FROM INPUT BUFFER 
      Modify the output Samples type (if it is being changed by this 
      program) by printing a format change for SAMPLE_TYPE for the 
      output buffer via "obuf" alias into the "override" dictionary.

      'cdds_out' function:
           This function will create an output dictionary from a 
           previous one, passing all it's history information along.  
    */</span>
   <a href="../capi/dict.html">cdds_dict</a>("override:", "print");
   <a href="../capi/printf.html">cdds_printf</a>("fmt:*:obuf.SAMPLE_TYPE", "\n");
   <a href="../capi/printf.html">cdds_printf</a>(" ", "   typedef complex SAMPLE_TYPE;\n");

   /*
    * open output buffer dictionary
    */
   out_buf_dict = <a href="../capi/out.html">cdds_out</a>("obuf", " ", in_buf_dict);

   /*
    * print any definitions that might have changed from the input
    */
   <a href="../capi/printf.html">cdds_printf</a>("size.axis(1)", "%d\n", nout);

   /*      
    * open output buffer binary (using "asp" format)
    */ 
   <a href="../capi/printf.html">cdds_printf</a>("obuf_fmt", "asp\n");
   out_buf_bin = <a href="../capi/open.html">cdds_open</a>(out_buf_dict, "obuf_fmt", " ", "m");
   if (out_buf_bin &lt; 0) {
      <a href="../capi/prterr.html">cdds_prterr</a>("Unable to open output buffer!\n");
   }

   /***********************************************************************
    *    open output data
    **********************************************************************/
   /*   
    * open the output dictionary from the internal output buffer
    */
   out_dict = <a href="../capi/out.html">cdds_out</a>("out", "stdout:", out_buf_dict);

   /*
    * open the output binary
    */
   out_bin = <a href="../capi/open.html">cdds_open</a>(out_dict, "out_format", "out_data", "w+");
   if (out_bin &lt; 0) {
      <a href="../capi/prterr.html">cdds_prterr</a>("Unable to open output file!\n");
   }

   /*
    * explicitly open the mapping from the internal output buffer to
    * the output dataset
    */
   <a href="../capi/openm.html">cdds_openm</a>(out_bin, 0, out_buf_bin, 0);

   /***********************************************************************
    *    process the data
    **********************************************************************/

   if (<a href="../capi/errors.html">cdds_errors</a>()) goto finish;

   doit(in_bin, in_buf_bin, out_buf_bin, out_bin, ns, nout, ndxsmp, scale,
     inbuf, outbuf);

   /***********************************************************************
    *    close files, clean-up, &amp; exit
    **********************************************************************/
   <span class="comment">/*
      CLOSE OUT
      'cdds_close' function:
           This function closes a dataset if the binary tag is &gt;= 0
           including all underlying dictionaries and data structures.
           This will also flush out all DDS data buffers out to the
           kernel.

      'cdds_closepr' function:
           This function will close out the print file (if opened)
           adding diagnosti  information, unread command line 
           parameters and termination status.  It will also exit
           the program giving a usable status code.
    */</span>
finish:
   <a href="../capi/close.html">cdds_close</a>(in_bin);
   <a href="../capi/close.html">cdds_close</a>(in_buf_bin);
   <a href="../capi/close.html">cdds_close</a>(out_buf_bin);
   <a href="../capi/close.html">cdds_close</a>(out_bin);

   <a href="../capi/closepr.html">cdds_closepr</a>();
}

/***********************************************************************
 * 
 *		doit
 *
 **********************************************************************/
void doit(int in_bin, int in_buf_bin, int out_buf_bin, int out_bin, 
          int ns, int nout, int ndxsmp, float scale, float* inbuf, 
          float* outbuf)
{
   int ier, i;

   /*
    * loop over each trace
    */
   <span class="comment">/*
         READ DATA
         'cdds_readm' function:
              This function reads a specified number of traces mapping
              each into the input internal buffer.  
              Check the number read in case of any problems.
    */</span>
   ier = <a href="../capi/readm.html">cdds_readm</a>(in_bin, 0, in_buf_bin, 0, inbuf, 1);
   while(ier == 1) {
      /*
       * save trace headers to output buffer
       */
      for(i=0;i&lt;ndxsmp-1;i++) outbuf[i] = inbuf[i];

      /*
       * process the trace Samples
       */
      process(ns, nout, scale, &amp;inbuf[ndxsmp], &amp;outbuf[ndxsmp]);
  
      /*
       * write the trace
       */
      <span class="comment">/*
            WRITE DATA
            'cdds_writem' function:
                 This function maps a specified number of traces from the
                 out_buf_bin to the out_bin and writes them out.  
                 Check the number written in case of any problems.
       */</span>
      ier = <a href="../capi/writem.html">cdds_writem</a>(out_bin, 0, out_buf_bin, 0, outbuf, 1);
      if (ier != 1) {
         <a href="../capi/prterr.html">cdds_prterr</a>("writing output\n");
         return;
      }

      /*
       *  read the next trace
       */
      ier = <a href="../capi/readm.html">cdds_readm</a>(in_bin, 0, in_buf_bin, 0, inbuf, 1);
   }
   
   return;
}
      
/***********************************************************************
 * 
 *		help
 *
 **********************************************************************/
void help()
{
   fprintf(stderr, "Template program demonstrating the use of the base\n");
   fprintf(stderr, "DDS routines for a simple trace-to-trace processing\n");
   fprintf(stderr, "scheme.\n");
   fprintf(stderr, "\n");
   fprintf(stderr, "usage:\n");
   fprintf(stderr, "   f_template [in=dat] [in_data=bin] [in_format=fmt] \\\n");
   fprintf(stderr, "   [out=dat] [out_data=bin] [out_format=fmt] \\\n");
   fprintf(stderr, "   [nout=n] [scale=f]\n");
   fprintf(stderr, "   \n");
   fprintf(stderr, "where:\n");
   fprintf(stderr, "   in=        input dataset\n");
   fprintf(stderr, "   in_data=   input binary\n");
   fprintf(stderr, "   in_format= input format\n");
   fprintf(stderr, "   out=       output dictionary\n");
   fprintf(stderr, "   out_data=  output binary\n");
   fprintf(stderr, "   out_format=output format\n");
   fprintf(stderr, "   nout=      output samples (dflt=input)\n");
   fprintf(stderr, "   scale=     scale factor (dflt=1.0)\n");
   fprintf(stderr, "\n");

   exit(0);
}
    </pre>

    <!*********************************************************************>
    <script type="text/javascript">footer()</script>
  </body>
</html>
