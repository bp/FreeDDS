<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Data Dictionary System: Developers "C" Templates (Template 3)</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <meta name="keywords" 
      content="Data Dictionary System Free Seismic Processing System">
    <link href="../../styles.css" type="text/css" rel="stylesheet">
    <script src="../../javascript.js" language="JavaScript"
      type="text/javascript"></script>
    <script type="text/javascript">
      if (location.search.search("remove=") >= 0) {
         var tmp = "position:absolute;left:-9999px;";
      } else {
         var tmp = "";
      }
      document.write("<style type='text/css'>.comment "
         +"{color:#c00000;"+tmp+"}<\/style>");

      function setRemoveOption() {
         var tmp;
         if (location.search.search("remove=") >= 0) {
            tmp = "'Add Tutorial Comments'";
         } else {
            tmp = "'Remove Tutorial Comments'";
         }
         document.write("<center><form><input type='button' value="
            +tmp+" onclick='toggleComments();'><\/form><\/center>");
      }      
         
      function toggleComments() {
         if (location.search.search("remove=") >= 0) {
            document.location.search = "";
         } else {
            location = "?remove=";
         }
      }
    </script>
    <style type="text/css">
      pre {color:#000000;}
    </style>  
  </head>
  <body>
    <script type="text/javascript">
      header("developers","ctemplates","c_template3")
    </script>
    <!*********************************************************************>

    <script type="text/javascript">setRemoveOption();</script>

    <pre>
/***********************************************************************
                   B P   A M E R I C A  
           PROPRIETARY - TO BE MAINTAINED IN CONFIDENCE 
                         COPYRIGHTED 2006
 ***********************************************************************

                           TEMPLATE 3

     <b>"C" template demonstrating the use of dds convenience </b>
     <b>routines for multiple input and output datasets using </b>
     <b>referencing input headers and creating new output headers.</b>
     <b>this also includes an optional input dataset and reading a </b>
     <b>full volume dataset.</b>

     This may have become pretty busy trying to show several different 
     techniques in this one template.  

     Written by Jerry Ehlers November 2006

 **********************************************************************/

#define _POSIX_SOURCE 1    /* Check POSIX Standard            */
#define ANSI               /* Turn on prototyping from cdds.h */

#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
<span class="comment">/*
   INCLUDE THE DDS API (Application Program Interface)
 */</span>
#include &lt;cdds.h&gt;           /* "C" dds include */

#define RCSID "$Id: c_template3.html 64 2009-03-04 21:24:41Z ehlersjw $"
#define TITLE "template3: C template using DDS convenience routines"

void doit(int, int, int, int, int, int, int, int, int, int, int, int,
          int, int, int, int, float, float, float, float, float, float,
          float, float, float, float, float, float, float, float, float, 
          float*, float*, float*, float*, char*);

/***********************************************************************
 *
 * main
 *
 **********************************************************************/
int main(int argc, char **argv)
{
   BIN_TAG in_bin=-1, aux_bin=-1, out_bin=-1;
   int ier, ibeta, n1_out, nh, nbytes, nwrds;
   int n1, n2, n3, n4, n1_aux, n2_aux, n3_aux, n1_vel, n2_vel, n3_vel;
   int rank, insmpl, outsmpl;
   int vsize[RANK_MAX];
   int check;
   float scale, d1_out, dh;
   float d1, d2, d3, d1_vel, d2_vel, d3_vel;
   float o1, o2, o3, o1_vel, o2_vel, o3_vel;
   float vdelta[RANK_MAX], vorigin[RANK_MAX];
   float *indata, *auxdata, *vel, *outdata;
   char genus[16], ctype[16], axis[3][AXISNAME_MAX];
   char *prog;

   /***********************************************************************
    *    initialize
    **********************************************************************/
   /*
    * get the program name
    */
   prog = strrchr(argv[0], '/');
   if (prog) prog++;
   else prog = argv[0];

   /*
    * pass the command line arguments on to DDS
    */
   setargcv(argc, argv);
   <span class="comment">/*
      OPEN THE PRINT FILE &amp; CHECK FOR HELP 
      'cdds_openpr' function:
           Open a printfile using the information automatically 
           generated by RCS in '$Id: c_template3.html 64 2009-03-04 21:24:41Z ehlersjw $'.  If the user specifies some
           form of help (-h help= HELP=...) on the command line,
           then the return value will be &lt; 0.
    */</span>
   ier = <a href="../capi/openpr.html">cdds_openpr</a>(prog, RCSID);
   if (ier &gt; 0) help();

   /***********************************************************************
    *    open input data file
    **********************************************************************/
   <span class="comment">/*    
      OPEN THE INPUT DATASET 
      'cddx_inhdr' function:
           This function opens the input file, with the specified 
           headers as integers in the trace buffer followed by the
           other input headers and then the data Samples as real values.
           The user can override the input format and binary data by  
           defining "in_format=" and&frasl;or "in_data=" since the first 
           argument is 'in'. If no headers are to be used yet you 
           still want to pass them to an output file, use <b>cddx_in2</b>.  
           If you simply want to read the Samples and throw away any 
           input headers, use <b>cddx_in</b>.
    */</span>
   in_bin = <a href="../cxapi/inhdr.html">cddx_inhdr</a>("in", "stdin:", TITLE, DDS_FLOAT, DDS_FLOAT,
                     "SrPtXC SrPtYC StaCor");
   <span class="comment">/*
      PRINT ERROR MESSAGE
      'cdds_prterr' function:
           Print an error message to the console (&amp; printfile if 
           exists). Error count is kept by DDS.  Check for errors later,  
           before processing to check for as many things as possible first.
    */</span>
   if (in_bin &lt; 0) {
      <a href="../capi/prterr.html">cdds_prterr</a>("Unable to open input data\n");
   }
   <span class="comment">/*
      RETRIEVE DATASET DEFINITIONS NEEDED BY APPLICATION 
      'cdds_scank' function:
           With ' ' as the second parameter, just return the number
           of axes defined.

      'cdds_scanf' function:
           Default values are assigned prior to definition retrieval.
           A variable are unchanged, if it is not specified.

           NOTE: What's special about the "size.axis(1)" definition?
           'axis(N)' is automatically converted to the Nth axis name.
           This allows hyper cube attributes to be retrieved by axis
           number, instead of axis name.  For example, "size.axis(1)"
           becomes "size.t" (assuming "axis=  t x y").

           WARNING: Do NOT use %i, use %d to scan for integers because
                    %i will interpret a value with a leading "0" as 
                    octal instead decimal (eg. 010 would be read as
                    8 instead of 10).
    */</span>
   /*
    *    Get axis names if needed later
    */
   <a href="../capi/scanf.html">cdds_scanf</a>("axis", "%s %s %s", axis[0], axis[1], axis[2]);

   rank = <a href="../capi/scank.html">cdds_scank</a>("axis", "");
   n4 = 1;
   <a href="../capi/scanf.html">cdds_scanf</a>("size.axis(1)", "%d", &amp;n1);
   <a href="../capi/scanf.html">cdds_scanf</a>("size.axis(2)", "%d", &amp;n2);
   <a href="../capi/scanf.html">cdds_scanf</a>("size.axis(3)", "%d", &amp;n3);
   <a href="../capi/scanf.html">cdds_scanf</a>("size.axis(4)", "%d", &amp;n4);
   <a href="../capi/scanf.html">cdds_scanf</a>("delta.axis(1)", "%f", &amp;d1);
   <a href="../capi/scanf.html">cdds_scanf</a>("delta.axis(2)", "%f", &amp;d2);
   <a href="../capi/scanf.html">cdds_scanf</a>("delta.axis(3)", "%f", &amp;d3);
   <a href="../capi/scanf.html">cdds_scanf</a>("origin.axis(1)", "%f", &amp;o1);
   <a href="../capi/scanf.html">cdds_scanf</a>("origin.axis(2)", "%f", &amp;o2);
   <a href="../capi/scanf.html">cdds_scanf</a>("origin.axis(3)", "%f", &amp;o3);

   if (rank &lt; 3 || rank &gt; 4) {
      <a href="../capi/prterr.html">cdds_prterr</a>("Can only handle 3D or 4D datasets in this program\n");
   }
   <span class="comment">/*
      RETRIEVE INDEX OFFSET TO THE SAMPLES 
      'cddx_index' function:
           This function returns an offset index to the input Samples
           in each trace buffer.
    */</span>
   tag = cdds_member(in_bin, 0, "Samples");
   genus = cdds_genus(in_bin, tag);

   insmpl = <a href="../cxapi/index.html">cddx_index</a>(in_bin, "Samples", DDS_FLOAT);
   if (strcmp(genus,"complex")) {
      insmpl = 2 * insmpl;
   }

   /***********************************************************************
    *    open optional auxillary input file
    **********************************************************************/
   <span class="comment">/*    
      OPEN THE OPTIONAL INPUT FILE 
      'cddx_in' function:
           This function opens an input file (throwing away any input
           trace headers) and without specifying a default filename (2nd
           argument) will simply return -2 without any errors.
    */</span>
   aux_bin = <a href="../cxapi/in.html">cddx_in</a>("aux", " ", TITLE);
   if (aux_bin &gt;= 0) {
      <a href="../capi/scanf.html">cdds_scanf</a>("size.axis(1)", "%d", &amp;n1_aux);
      <a href="../capi/scanf.html">cdds_scanf</a>("size.axis(2)", "%d", &amp;n2_aux);
      <a href="../capi/scanf.html">cdds_scanf</a>("size.axis(3)", "%d", &amp;n3_aux);
      if (n1_aux != n1 || n2_aux != n2 || n3_aux != n3) {
         <a href="../capi/prterr.html">cdds_prterr</a>("\"aux\" input dataset not conformable with \"in\"\n");
      }
   } else if (aux_bin != -2) {
      <a href="../capi/prterr.html">cdds_prterr</a>("Unable to open aux input\n");
   }

   /***********************************************************************
    *    open and read velocity input file
    **********************************************************************/
   <span class="comment">/*    
      OPEN AND READ THE VELOCITY INPUT FILE 
      'cddx_readall' function:
           This function opens the an file, allocates the buffer, reads
           the entire dataset, and closes the file.  This is convenient
           when you need to have an entire dataset in memory.  Just be
           aware that the program could abort if it is unable to 
           allocate the required memory.  
    */</span>
   ier = <a href="../cxapi/readll.html">cddx_readall</a>("in", &amp;vel, &amp;rank, vsize, vdelta, vorigin);
   if (ier &lt;= 0) {
      <a href="../capi/prterr.html">cdds_prterr</a>("Unable to open \"vel\" dataset\n");
   } else if (rank != 3 &amp;&amp; n2_vel*n3_vel != 1) {
      <a href="../capi/prterr.html">cdds_prterr</a>(
     *        "\"vel\" must be 3D or a single velocity function\n");
   }

   n1_vel = vsize[0];
   n2_vel = vsize[1];
   n3_vel = vsize[2];
   d1_vel = vdelta[0];
   d2_vel = vdelta[1];
   d3_vel = vdelta[2];
   o1_vel = vorigin[0];
   o2_vel = vorigin[1];
   o3_vel = vorigin[2];

   /***********************************************************************
    *    read parameters
    **********************************************************************/
   <span class="comment">/*
      RETRIEVE COMMAND LINE PARAMETERS
      'cdds_dict' function:
           'cdds_dict' selects the 'par:' dictionary for scanning.
           This dictionary only contains definitions from the command
           line, and parameter dictionaries ("par=  fn1  fn2 ...").
           Parameters ("in= ", "out_format= ", etc.) for the current
           process can be read, without ambiguity from the input history 
           (ie. local parameters only).
    */</span>
   <a href="../capi/dict.html">cdds_dict</a>("par:", "scan");

   /*
    * get beta, scale and ctype
    * (initialize ibeta &amp; scale defaults; ctype is required)
    */
   ibeta = 7;
   scale = 1.0;
   ctype[0] ='\0';
   <a href="../.capi/scanf.html">cdds_scanf</a>("beta", "%d", &amp;ibeta);
   <a href="../.capi/scanf.html">cdds_scanf</a>("scale", "%f", &amp;scale);
   <a href="../.capi/scanf.html">cdds_scanf</a>("type", "%s", ctype);
   if (ier &lt; 0) {
      <a href="../capi/prterr.html">cdds_prterr</a>("\"type\" MUST be specified\n");
   }

   /*
    * get output file parameters
    */
   n1_out = n1;
   d1_out = d1;
   nh = 1;
   dh = 50.0;
   <a href="../capi/scanf.html">cdds_scanf</a>("n1_out", "%d", &amp;n1_out);
   <a href="../capi/scanf.html">cdds_scanf</a>("d1_out", "%f", &amp;d1_out);
   <a href="../capi/scanf.html">cdds_scanf</a>("nh", "%d", &amp;nh);
   <a href="../capi/scanf.html">cdds_scanf</a>("dh", "%f", &amp;dh);
   <span class="comment">/*
      RETRIEVE SWITCH PARAMETER
      'cdds_switch' function:
           This function returns non-zero if specified with nothing or
           "1 y Y yes Yes YES t T true True TRUE"; zero if specified 
           with "0 n N no No NO f F false False FALSE"; otherwise it
           returns the default value (2nd argument).
    */</span>
   check = <a href="../capi/switch.html">cdds_switch</a>("check", 0);   

   /***********************************************************************
    *    print user parameters
    **********************************************************************/
   <span class="comment">/*
      PRINT MESSAGES 
      'cdds_prtmsg' function:
           This function prints a formatted message to the print file
           opened by "cdds_openpr"; otherwise to the console (stderr).

      'cdds_prtcon' function:
           This function prints a formatted message to the console and
           to the print file if opened.
   
      'cdds_prtmsg' function:
           This function prints a formatted error message to the console 
           and to the print file if opened.  It also keeps track of the
           number of error messages printed for "cdds_closepr".
    */</span>
   <a href="../capi/prtmsg.html">cdds_prtmsg</a>("\n*** USER PARAMETERS ***\n\n");
   <a href="../capi/prtmsg.html">cdds_prtmsg</a>("\tbeta   =%d\n", ibeta);
   <a href="../capi/prtmsg.html">cdds_prtmsg</a>("\tscale  =%g\n", scale);
   <a href="../capi/prtmsg.html">cdds_prtmsg</a>("\ttype   =%s\n", ctype);
   <a href="../capi/prtmsg.html">cdds_prtmsg</a>("\tn1_out =%d\n", n1_out);
   <a href="../capi/prtmsg.html">cdds_prtmsg</a>("\td1_out =%g\n", d1_out);
   <a href="../capi/prtmsg.html">cdds_prtmsg</a>("\tnh     =%d\n", nh);
   <a href="../capi/prtmsg.html">cdds_prtmsg</a>("\tdh     =%g\n", dh);
   if (check) {
      <a href="../capi/prtmsg.html">cdds_prtmsg</a>("\tcheck  =YES\n");
   } else {
      <a href="../capi/prtmsg.html">cdds_prtmsg</a>("\tcheck  =NO\n");
   }
   <a href="../capi/prtmsg.html">cdds_prtmsg</a>("\n");

   /***********************************************************************
    *    allocate dynamic arrays
    **********************************************************************/
   <span class="comment">/*
      Don't allocate arrays if there are already any errors; 
      we could have bad array sizes
    */</span> 
   if (cdds_errors()) goto finish;
   <span class="comment">/*
      ALLOCATE DYNAMIC ARRAYS 
      'cdds_prec' function:
           This function returns the number of bytes for each trace in
           an open binary.

      'cdds_malloc' function:
           This function allocates memory or reports an error &amp; aborts.
           Storage can be released by calling "cdds_free".  Use 
           "dds_debug= dbg_call" will cause DDS to check memory at
           each api call.
   */</span>
   nbytes = <a href="../capi/prec.html">cdds_prec</a>(in_bin, 0);
   nwrds = nbytes/sizeof(float);
   indata = <a href="../capi/malloc.html#malloc">cdds_malloc</a>(n2 * nbytes);
   nbytes = <a href="../capi/prec.html">cdds_prec</a>(out_bin, 0);
   outdata = <a href="../capi/malloc.html#malloc">cdds_malloc</a>(nbytes);

   /* 
    * If aux opened, allocate memory for a single aux trace. 
    * (No headers used, so we know how many Samples there are)
    */
   if (aux_bin &gt;= 0) {
      auxdata = <a href="../capi/malloc.html#malloc">cdds_malloc</a>(n1_aux * sizeof(float));
   }

   /***********************************************************************
    *    open output dataset
    **********************************************************************/
   <span class="comment">/*
      CHECK FOR ERRORS BEFORE PROCEEDING ANY FURTHER 
      'cdds_errors' function:
           This function returns the number of errors reported using
           "cdds_prterr".  No reason to create a new output if there
           have been any errors.
    */</span>
   if (<a href="../capi/errors.html">cdds_errors</a>()) goto finish;
   <span class="comment">/*
      CREATE OUTPUT FROM INPUT DICTIONARY 
      'cddx_outhdr' function:
           This function will create an output dataset from the input
           binary passing all it's history information and trace headers
           along.  The specified headers can be newly created or 
           existing headers and will be in order at the beginning of 
           the trace buffer, followed by any other trace headers, and
           last are the Samples.  The user can override the output 
           format and binary data by defining "out_format=" or  
           "out_data=" since the first argument is 'out'.  If you 
           simply want to pass the headers and Samples along as the  
           same data types, use <b>cddx_out</b>.

           With the output convenience routines, the binaries are not 
           actually opened until the binary tag is first used for I/O. 
           This way the internal buffer definitions for the output file  
           can be redefined (eg. axis, size, delta, origin...).  So no
           need to check out_bin until after it really gets opened.
    */</span>
   out_bin = <a href="../cxapi/outhdr.html">cddx_outhdr</a>("out", "stdout:", TITLE, in_bin, DDS_FLOAT,
                       DDS_FLOAT, "RcPtXC RcPtYC StaCor");
   <span class="comment">/*
      MODIFY THE OUTPUT AXIS 
      'cddx_dict' function:
           This function changes the dictionary mode associated with the 
           binary tag.  If redefining the 'axis', then we need to rescan
           the dictionary to get DDS to reset the axis names internally
           and set it back for printing so we can use the ".axis(1)" 
           internal DDS function instead of having to use the actual
           axis names in the definitions.
    */</span>
   <a href="../capi/printf.html">cdds_printf</a>("axis", "%s  h %s %s\n", axis[0], axis[1], axis[2]);
   <a href="../cxapi/dict.html">cddx_dict</a>(out_bin, "scan");
   <a href="../cxapi/dict.html">cddx_dict</a>(out_bin, "print");

   /*
    * Only need to defined the parameters that might have changed from 
    * or are not in the input dataset.
    */
   <a href="../capi/printf.html">cdds_printf</a>("size.axis(1)", "%d\n", n1_out);
   <a href="../capi/printf.html">cdds_printf</a>("delta.axis(1)", "%f\n", d1_out);
   <a href="../capi/printf.html">cdds_printf</a>("size.h", "%d\n", nh);
   <a href="../capi/printf.html">cdds_printf</a>("delta.h", "%f\n", dh);
   <a href="../capi/printf.html">cdds_printf</a>("origin.h", "0\n");
   <span class="comment">/*
      FORCE OPEN THE OUTPUT BINARIES
      'cdds_lseek' function:
          This function seeks to a specific trace position.  It is used 
          here simply to force open the internal and output binaries.
          Now we can check if it was really opened.
    */</span>
   ier = <a href="../capi/lseek.html">cdds_lseek</a>(out_bin, 0, 0, SEEK_SET);
   if (ier &lt; 0) {
      <a href="../capi/prterr.html">cdds_prterr</a>("Unable to open output dataset!\n");
   }

   /*
    * Now that the output is open, get the index to the output Samples
    */
   outsmpl = <a href="../cxapi/index.html">cddx_index</a>(out_bin, "Samples", DDS_FLOAT);

   /***********************************************************************
    *    process the data
    **********************************************************************/

   if (<a href="../capi/errors.html">cdds_errors</a>()) goto finish;

   doit(in_bin, aux_bin, out_bin, ibeta, n1_out, nh, n1, n2, n3, n4,  
          n1_vel, n2_vel, n3_vel, insmpl, outsmpl, int nwrds, check, scale, 
          d1_out, dh, d1, d2, d3, d1_vel, d2_vel, d3_vel, o1, o2, o3, 
          o1_vel, o2_vel, o3_vel, indata, auxdata, vel, outdata, ctype);

   /***********************************************************************
    *    close files, clean-up, &amp; exit
    **********************************************************************/
   <span class="comment">/*
      CLOSE OUT
      'cdds_close' function:
           This function closes a dataset if the binary tag is &gt;= 0
           including all underlying dictionaries and data structures.
           This will also flush out all DDS data buffers out to the
           kernel.

      'cdds_closepr' function:
           This function will close out the print file (if opened)
           adding diagnosti  information, unread command line 
           parameters and termination status.  It will also exit
           the program giving a usable status code.
    */</span>
finish:
   <a href="../capi/close.html">cdds_close</a>(in_bin);
   <a href="../capi/close.html">cdds_close</a>(aux_bin);
   <a href="../capi/close.html">cdds_close</a>(out_bin);

   <a href="../capi/closepr.html">cdds_closepr</a>();
}

/***********************************************************************
 * 
 *		doit
 *
 **********************************************************************/
void doit(int in_bin, int aux_bin, int out_bin, int ibeta, int n1_out, 
          int nh, int n1, int n2, int n3, int n4, int n1_vel, int n2_vel,
          int n3_vel, int insmpl, int outsmpl, int nwrds, int check, 
          float scale, float d1_out, float dh, float d1, float d2, 
          float d3,float d1_vel, float d2_vel, float d3_vel, float o1, 
          float o2, float o3, float o1_vel, float o2_vel, float o3_vel, 
          float* indata, float* auxdata, float* vel, float* outdata,
          char* ctype)
{
   int ier, i1, i2, i3;
   float srcx, srcy, dead;

   /*
    * loop over records
    */
   for(i3=0;i3&lt;n3;i3++) {
      <span class="comment">/*
         READ DATA
         'cddx_read' function:
              This function reads a specified number of traces.  
              Check the number read in case of any problems.
       */</span>
      ier = <a href="../cxapi/read.html">cddx_read</a>(in_bin, indata, n2);
      if (ier != n2) {
         <a href="../capi/prterr.html">cdds_prterr</a>("reading \"in\" input\n");
         return;
      }

      /*
       * process a record
       */
      for(i2=0;i2&lt;n2;i2++) {
         /*
          * read an auxillary trace if available
          * otherwise use indata
          */
         if (aux_bin &gt;= 0) {
            ier = <a href="../cxapi/read.html">cddx_read</a>(aux_bin, auxdata, 1);
            if (ier != 1) {
               <a href="../capi/prterr.html">cdds_prterr</a>("reading \"aux\" input\n");
               return;
            }
         } else {
            for(i1=0;i1&lt;n1;i1++) {
               auxdata[i1]=indata[insmpl+i1+i2*nwrds];
            }
         } 

         /*
          * get needed input trace headers
          */
         srcx = indata[0+i2*nwrds];
         srcy = indata[1+i2*nwrds];
         dead = indata[2+i2*nwrds];
         <span class="comment">/*
            MAP INPUT HEADERS TO OUTPUT HEADERS
            'cdds_map' function:
                 This function maps the input trace to the output trace.  
                 Using the open output convenience function, only maps 
                 trace headers (not "Samples").
          */</span>
         <a href="../capi/map.html">cdds_map</a>(out_bin, 0, outdata, in_bin, 0, &amp;indata[i2*nwrds]);

         /*
          * process this trace
          */
         if (dead != 30000) {
            algorithm(n1, n2, n3, srcx, srcy, scale, ibeta, check, ctype,
                      &amp;indata[insmpl+i2*nwrds], auxdata, vel, 
                      outdata[outsmpl]);
         }
         <span class="comment">/*
            WRITE DATA
            'cddx_write' function:
                 This function writes a specified number of traces.  
                 Check the number written in case of any problems.
          */</span>
         ier = <a href="../cxapi/write.html">cddx_write</a>(out_bin, outdata, 1);
         if (ier != 1) {
            <a href="../capi/prterr.html">cdds_prterr</a>("writing output\n");
            return;
         }
      }
   }

   return;
}
    </pre>

    <!*********************************************************************>
    <script type="text/javascript">footer()</script>
  </body>
</html>
