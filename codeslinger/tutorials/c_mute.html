<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Data Dictionary System: Code Slinger Tutorials (work with headers)</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <meta name="keywords" 
      content="Data Dictionary System Free Seismic Processing System">
    <link href="../../styles.css" type="text/css" rel="stylesheet">
    <script src="../../javascript.js" language="JavaScript"
      type="text/javascript"></script>
    </script>
    <style type="text/css">
      pre {color:#000000;}
    </style>
  </head>
  <body>

    <script type="text/javascript">
      header("codeslinger","tutorials","c_xyrange.c")
    </script>
    <!*********************************************************************>

<pre>
/***********************************************************************/
/*                                                                     */
/* Get the range of values in user selected headers                    */
/* Use source/receiver XY headers as defaults                          */
/*                                                                     */
/* An example of reasonably defensive and robust coding.               */
/*                                                                     */
/***********************************************************************/

#include "math.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#include "cdds.h"


/* Macros */
#define MIN(x,y)  ((x) &lt; (y) ? (x) : (y))
#define MAX(x,y)  ((x) &gt; (y) ? (x) : (y))


/* Function prototypes */
void help(char *prog, char *Title);


/* Main */
int main(int argc, char **argv)
{

/* For DDS functions. Arguments and return values */
   char  *prog, *Title;
   int   ier;
   BIN_TAG fd_in;

/* Data attributes */
   int   n1,n2,n3, ntrc_words;
   FIELD_TAG iSrcX,iSrcY, iGrpX,iGrpY;

/* Internal dynamic array */
   float *record;

/* Internal scalar values and loop counters */
   char   *SrcX,*SrcY, *GrpX,*GrpY;
   const char *defn;
   int    i2,i3, ntr;
   int    ier_sx,ier_sy, ier_gx,ier_gy;
   double sx_min,sx_max,sx_here, sy_min,sy_max,sy_here;
   double gx_min,gx_max,gx_here, gy_min,gy_max,gy_here;

/*-------------------------------------------------------------------*/

/****************/
/* Initialize   */
/****************/
   setargcv(argc, argv);


/************************/
/* Set prog and Title   */
/************************/
   prog="c_xyrange";
   Title="c_xyrange: Get the range of selected trace header words";


/*****************************************************************/
/* Open the print file and dump command-line help as requested   */
/*****************************************************************/
   ier=cdds_openpr(prog,"");
   if (ier&gt;0) help(prog,Title);


/*****************************************************/
/* Retrieve alternate headers from user parameters   */
/*****************************************************/
   ier=cdds_dict("par:","scan");

   if ( ier=cdds_scant("SrcX srcx",&amp;defn) &gt; 0 ) {
      SrcX = (char*)malloc(ier+1);
      strcpy(SrcX,defn);
   } else {
      SrcX="SrPtXC";
   }

   if ( ier=cdds_scant("SrcY srcy",&amp;defn) &gt; 0 ) {
      SrcX = (char*)malloc(ier+1);
      strcpy(SrcY,defn);
   } else {
      SrcY="SrPtYC";
   }

   if ( ier=cdds_scant("GrpX grpx",&amp;defn) &gt; 0 ) {
      GrpX = (char*)malloc(ier+1);
      strcpy(GrpX,defn);
   } else {
      GrpX="RcPtXC";
   }

   if ( ier=cdds_scant("GrpY grpy",&amp;defn) &gt; 0 ) {
      GrpX = (char*)malloc(ier+1);
      strcpy(GrpY,defn);
   } else {
      GrpY="RcPtYC";
   }


/************************************************************************/
/* Open input.  Retrieve data characteristics when open is successful   */
/************************************************************************/
   fd_in=cddx_in2("in","stdin:",Title);

   if (fd_in&lt;0) {

      ier=cdds_prterr("Opening input data\n");

   } else {

      ier=cdds_scanf("size.axis(1)","%d",&amp;n1);
      ier=cdds_scanf("size.axis(2)","%d",&amp;n2);
      n3=cdds_axis_prod(3);

      ntrc_words=cdds_prec(fd_in,0)/sizeof(float);
      if (ntrc_words&lt;0)
         ier=cdds_prterr("Cannot determine trace length\n");

      /* Go find the headers within the trace structure */
      iSrcX=cdds_member(fd_in,0,SrcX);
      iSrcY=cdds_member(fd_in,0,SrcY);
      iGrpX=cdds_member(fd_in,0,GrpX);
      iGrpY=cdds_member(fd_in,0,GrpY);

      if (iSrcX&lt;0) cdds_prterr("Header %s is not available\n",SrcX);
      if (iSrcY&lt;0) cdds_prterr("Header %s is not available\n",SrcY);
      if (iGrpX&lt;0) cdds_prterr("Header %s is not available\n",GrpX);
      if (iGrpY&lt;0) cdds_prterr("Header %s is not available\n",GrpY);

   }


/*********************************************/
/* Check whether any errors were reported.   */
/* If so, clean up and terminate now.        */
/*********************************************/
   if ( cdds_errors()&gt;0) {
      if (fd_in&gt;0) cdds_close(fd_in);
      cdds_closepr();
      exit(0);
   }


/*****************************/
/* Allocate array for data   */
/*****************************/
   record=(float*)cdds_malloc((ntrc_words)*n2*sizeof(float));


/***********************************/
/* Initialize the min/max values   */
/***********************************/
   sx_min= HUGE_VAL;
   sx_max=-HUGE_VAL;

   sy_min= HUGE_VAL;
   sy_max=-HUGE_VAL;

   gx_min= HUGE_VAL;
   gx_max=-HUGE_VAL;

   gy_min= HUGE_VAL;
   gy_max=-HUGE_VAL;


/**********************************************/
/* Loop over input data, set min/max values   */
/**********************************************/
   for (i3=0; i3&lt;n3; i3++) {

      ntr=cddx_read(fd_in,record,n2);

      if (ntr != n2) {

         cdds_prterr("Reading record %d: %d traces\n\0",i3,ntr);

      } else {

         for (i2=0; i2&lt;n2; i2++) {

            ier_sx=cdds_getd(fd_in,iSrcX,&amp;record[i2*(ntrc_words)],&amp;sx_here,1);
            ier_sy=cdds_getd(fd_in,iSrcY,&amp;record[i2*(ntrc_words)],&amp;sy_here,1);
            ier_gx=cdds_getd(fd_in,iGrpX,&amp;record[i2*(ntrc_words)],&amp;gx_here,1);
            ier_gy=cdds_getd(fd_in,iGrpY,&amp;record[i2*(ntrc_words)],&amp;gy_here,1);

            if (ier_sx&lt;1) {
               cdds_prterr("Failed to \"get\" header %s\n",SrcX);
            } else {
               sx_min=MIN(sx_min,sx_here);
               sx_max=MAX(sx_max,sx_here);
            }

            if (ier_sy&lt;1) {
               cdds_prterr("Failed to \"get\" header %s\n",SrcY);
            } else {
               sy_min=MIN(sy_min,sy_here);
               sy_max=MAX(sy_max,sy_here);
            }

            if (ier_gx&lt;1) {
               cdds_prterr("Failed to \"get\" header %s\n",GrpX);
            } else {
               gx_min=MIN(gx_min,gx_here);
               gx_max=MAX(gx_max,gx_here);
            }

            if (ier_gy&lt;1) {
               cdds_prterr("Failed to \"get\" header %s\n",GrpY);
            } else {
               gy_min=MIN(gy_min,gy_here);
               gy_max=MAX(gy_max,gy_here);
            }

            if (cdds_errors() != 0) {
               cdds_prterr("Record %d, Trace %d\n",i3,i2);
               break;
            }
         }

      }

      if (cdds_errors() != 0) {
         cdds_free(record);
         ier=cdds_close(fd_in);
         ier=cdds_closepr();
         exit(0);
      }
   }


/***********************/
/* Report the result   */
/***********************/
   cdds_prtcon("\n");
   cdds_prtcon("Range for header %15s: %lg to %lg\n",SrcX,sx_min,sx_max);
   cdds_prtcon("Range for header %15s: %lg to %lg\n",SrcY,sy_min,sy_max);
   cdds_prtcon("Range for header %15s: %lg to %lg\n",GrpX,gx_min,gx_max);
   cdds_prtcon("Range for header %15s: %lg to %lg\n",GrpY,gy_min,gy_max);
   cdds_prtcon("\n");


/**************/
/* Clean up   */
/**************/
   cdds_free(record);
   ier=cdds_close(fd_in);
   ier=cdds_closepr();


/**********/
/* Exit   */
/**********/
   exit(0);
}




/* Function help */
void help( char *prog, char *Title)
{
   fprintf(stderr,"\n");
   fprintf(stderr," %s\n",Title);
   fprintf(stderr,"\n");
   fprintf(stderr," Parameter....Meaning........................Default\n");
   fprintf(stderr,"\n");
   fprintf(stderr,"  in=[dict]   input dictionary                stdin:\n");
   fprintf(stderr,"\n");
   fprintf(stderr,"  SrcX=       Override for SrcX header        SrPtXC\n");
   fprintf(stderr,"  SrcY=          \"    \"    SrcY   \"           SrPtYC\n");
   fprintf(stderr,"  GrpX=          \"    \"    GrpX   \"           RcPtXC\n");
   fprintf(stderr,"  GrpY=          \"    \"    GrpY   \"           RcPtYC\n");
   fprintf(stderr,"\n");
   fprintf(stderr,"  USAGE: %s in=[in_dict] \\\n",prog);
   fprintf(stderr,"            [ SrcX=[SrcX] SrcY=[SrcY] GrpX=[GrpX] GrpY=[GrpY]\n");
   fprintf(stderr,"\n");

   exit(0);
}
</pre>
  
    <!*********************************************************************>
    <script type="text/javascript">footer()</script>
  </body>
</html>
