<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Data Dictionary System: Code Slinger Examples (work around headers)</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <meta name="keywords" 
      content="Data Dictionary System Free Seismic Processing System">
    <link href="../../styles.css" type="text/css" rel="stylesheet">
    <script src="../../javascript.js" language="JavaScript"
      type="text/javascript"></script>
    </script>
    <style type="text/css">
      pre {color:#000000;}
    </style>
  </head>
  <body>

    <script type="text/javascript">
      header("codeslinger","basiccodes","f_taper.F")
    </script>
    <!*********************************************************************>

<pre>
c***********************************************************************
c
c taper the beginning and end of live data on axis 1
c
c***********************************************************************

      program f_taper

      implicit none

#include &lt;<a href="../resources/fdds.h.html">fdds.h</a>&gt;

c For DDS functions. Arguments and return values
      character prog*(7), Title*(80)
      integer   ier, fd_in, fd_out

      integer*8 ier8,izero8
      parameter (izero8=0)

c Data attributes
      integer n1,n2,n3
      integer ismptag, nhdr

c User parameters
      integer ntaper
      logical lverb, lcos

c Internal dynamic array
      real    record(1), taper(1)
      pointer (ptr_taper,taper)
      pointer (ptr_record,record)

c Internal loop counters and other scalar values
      integer i3

c-------------------------------------------------------------------
c
c Initialize the Title
c
      prog='f_taper'
      Title=prog//': taper the beginning and end of live data'

c
c Open the print file and dump command-line help is requested
c
      ier=<a href="../fapishort/fdds_openpr.html">fdds_openpr</a>(prog,'')
      if (ier.gt.0) call help(prog,Title)

c
c Open input file
c Retrieve data characteristics when successful
c
      fd_in=<a href="../fapishort/fddx_in2.html">fddx_in2</a>('in','stdin:',Title)
      if (fd_in.lt.0) then

         ier=<a href="../fapishort/fdds_prterr.html">fdds_prterr</a>('Unable to open input data file!\n\0')

      else

         ier=<a href="../fapishort/fdds_scanf.html">fdds_scanf</a>('size.axis(1)','%d\0',n1)
         ier=<a href="../fapishort/fdds_scanf.html">fdds_scanf</a>('size.axis(2)','%d\0',n2)
         n3=<a href="../fapishort/fdds_axis_prod.html">fdds_axis_prod</a>(3)

         ismptag=<a href="../fapishort/fdds_member.html">fdds_member</a>(fd_in,0,"Samples")
         nhdr   =<a href="../fapishort/fdds_index.html">fdds_index</a>(fd_in,ismptag,DDS_REAL)

      endif

c
c Retrieve command line and parfile parameters
c
      ier=<a href="../fapishort/fdds_dict.html">fdds_dict</a>('par:','scan')

      ntaper=10
      ier=<a href="../fapishort/fdds_scanf.html">fdds_scanf</a>('ntaper nt','%d\0',ntaper)

      lcos=.false.
      if (<a href="../fapishort/fdds_scank.html">fdds_scank</a>('cosine cos',DDS_TRUE_KEY).gt.0) lcos=.true.

      lverb=.false.
      if (<a href="../fapishort/fdds_scank.html">fdds_scank</a>('verbose',DDS_TRUE_KEY).gt.0) lverb=.true.

c
c Set up the output dictionary ... Open with lseek8
c
      fd_out=<a href="../fapishort/fddx_out.html">fddx_out</a>('out','stdout:',Title,fd_in)
      if (fd_out.lt.0) then
         ier=<a href="../fapishort/fdds_prterr.html">fdds_prterr</a>('Unable to open output buffer dict!\n\0')
      endif

      ier8=<a href="../fapishort/fdds_lseek8.html">fdds_lseek8</a>(fd_out,0,izero8,SEEK_SET)
      if (ier8.lt.izero8) then
         ier=<a href="../fapishort/fdds_prterr.html">fdds_prterr</a>('Unable to open output data file!\n\0')
      endif

c
c Allocate data arrays
c
      ptr_taper=<a href="../fapishort/fdds_malloc8.html">fdds_malloc8</a>(dble(ntaper)*SIZEOF_REAL)
      ptr_record=<a href="../fapishort/fdds_malloc8.html">fdds_malloc8</a>(dble(n1+nhdr)*n2*SIZEOF_REAL)

c
c Check for set up errors
c
      if (<a href="../fapishort/fdds_errors.html">fdds_errors</a>().gt.0) then
         ier=<a href="../fapishort/fdds_close.html">fdds_close</a>(fd_in)
         ier=<a href="../fapishort/fdds_close.html">fdds_close</a>(fd_out)
         ier=<a href="../fapishort/fdds_closepr.html">fdds_closepr</a>()
         stop
      endif

c
c Loop over n3, read-taper-write
c
      do i3 = 1,n3

         if (lverb .and. mod(i3,10).eq.0) then
            ier=<a href="../fapishort/fdds_prtcon.html">fdds_prtcon</a>('Record %5d of %5d\n\0',i3,n3)
         endif


         if (<a href="../fapishort/fddx_read.html">fddx_read</a>(fd_in,record,n2).ne.n2) then
            ier=<a href="../fapishort/fdds_prterr.html">fdds_prterr</a>('Reading record %d\n\0',i3)
            ier=<a href="../fapishort/fdds_close.html">fdds_close</a>(fd_in)
            ier=<a href="../fapishort/fdds_close.html">fdds_close</a>(fd_out)
            ier=<a href="../fapishort/fdds_closepr.html">fdds_closepr</a>()
            stop
         endif

         call apply_taper(record, n1,n2,nhdr, taper,ntaper, lcos)

         if (<a href="../fapishort/fddx_write.html">fddx_write</a>(fd_out,record,n2).ne.n2) then
            ier=<a href="../fapishort/fdds_prterr.html">fdds_prterr</a>('Writing record %d\n\0',i3)
            ier=<a href="../fapishort/fdds_close.html">fdds_close</a>(fd_in)
            ier=<a href="../fapishort/fdds_close.html">fdds_close</a>(fd_out)
            ier=<a href="../fapishort/fdds_closepr.html">fdds_closepr</a>()
            stop
         endif

      enddo

c
c Clean up
c
      ier=<a href="../fapishort/fdds_free.html">fdds_free</a>(ptr_taper)
      ier=<a href="../fapishort/fdds_free.html">fdds_free</a>(ptr_record)
      ier=<a href="../fapishort/fdds_close.html">fdds_close</a>(fd_in)
      ier=<a href="../fapishort/fdds_close.html">fdds_close</a>(fd_out)
      ier=<a href="../fapishort/fdds_closepr.html">fdds_closepr</a>()

c
c Stop
c
      stop
      end




c***********************************************************************
c
c subroutine to print help when requested on the command line
c
c***********************************************************************

      subroutine help(prog,Title)

      implicit none

      character prog*(*), Title*(*)
      integer lnblnk

      write(0,*)''
      write(0,*)Title(1:lnblnk(Title))
      write(0,*)''
      write(0,*)' Parameter....Meaning..........................Default'
      write(0,*)''
      write(0,*)'  in=         input dictionary                  stdin:'
      write(0,*)'  out=        output dictionary                stdout:'
      write(0,*)''
      write(0,*)'  ntaper=     # samples in taper                    10'
      write(0,*)'  cosine=     use cosine taper (default: linear)    no'
      write(0,*)''
      write(0,*)'  verbose=    verbose output                        no'
      write(0,*)''
      write(0,*)'  USAGE: '//prog(1:lnblnk(prog))
      write(0,*)'           in=[in_dict] out=[out_dict]'
      write(0,*)'           [ ntaper=[ntaper] cosine=[y|n]'
      write(0,*)'             verbose=[y|n] ]'
      write(0,*)''

      stop

      return
      end




c***********************************************************************
c
c apply a taper to the onset and offset of data in traces
c
c***********************************************************************

      subroutine apply_taper (record, n1,n2,nhdr, taper,ntaper, lcos)

      implicit none

c Arguments
      integer n1,n2, nhdr, ntaper
      logical lcos
      real    record(1-nhdr:n1,n2)
      real    taper(ntaper)

c Locals
      integer i1,i11,i1n, i2, it
      real    pi

c Build the taper weights
      if (lcos) then
         pi = acos(-1.0)
         do it = 1,ntaper
            taper(it) = 0.5+0.5*cos(pi*(ntaper-it+1)/ntaper)
         enddo
      else
         do it=1,ntaper
            taper(it) = real(it-1)/ntaper
         enddo
      endif

c Go apply the tapers
      do i2 = 1,n2

         ! find the onset of data at the beginning of the trace
         i11 = 0
         i1  = 1
         do while (i11.eq.0 .and. i1.lt.n1)
            if (record(i1,i2).ne.0.0) i11 = i1
            i1=i1+1
         enddo

         ! apply the taper
         if (i11.gt.0) then
            it=0
            do i1=i11,min(i11+ntaper-1,n1)
               it=it+1
               record(i1,i2) = record(i1,i2) * taper(it)
            enddo
         endif

         ! find the offset of data at the end of the trace
         i1n = n1+1
         i1  = n1
         do while (i1n.eq.n1+1 .and. i1.gt.1)
            if (record(i1,i2).ne.0.0) i1n = i1
            i1=i1-1
         enddo

         ! apply the taper
         if (i1n.le.n1) then
            it=ntaper+1
            do i1=max(1,i1n-ntaper+1),i1n
               it=it-1
               record(i1,i2) = record(i1,i2) * taper(it)
            enddo
         endif

      enddo

      return
      end
</pre>
  
    <!*********************************************************************>
    <script type="text/javascript">footer()</script>
  </body>
</html>
