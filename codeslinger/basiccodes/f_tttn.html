<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>Data Dictionary System: Code Slinger Examples (access samples)</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    <meta name="keywords" 
      content="Data Dictionary System Free Seismic Processing System">
    <link href="../../styles.css" type="text/css" rel="stylesheet">
    <script src="../../javascript.js" language="JavaScript"
      type="text/javascript"></script>
    </script>
    <style type="text/css">
      pre {color:#000000;}
    </style>
  </head>
  <body>

    <script type="text/javascript">
      header("codeslinger","basiccodes","f_tttn.F")
    </script>
    <!*********************************************************************>

<pre>
c***********************************************************************
c
c Data independent (removable) scaling using t**n functions
c
c***********************************************************************

      program f_tttn

      implicit none

#include &lt;<a href="../resources/fdds.h.html">fdds.h</a>&gt;

c For DDS functions. Arguments and return values
      character prog*(6), Title*(80)
      integer   ier, fd_in, fd_out
      integer*8 ier8,izero8
      parameter (izero8=0)

c Data attributes
      integer n1,n2,n3
      real    d1, o1

c User parameters
      logical lverb, linv
      real    alpha, power, eps

c Internal dynamic arrays
      real    record(1), times(1), gain(1)
      pointer (ptr_record,record)
      pointer (ptr_times,times)
      pointer (ptr_gain,gain)

c internal scalar values and loop counters
      integer n2_in,n2_out, i3

c-------------------------------------------------------------------
c
c Initialize the Title
c
      prog='f_tttn'
      Title=prog//': Time varying, data independent scaling'

c
c Open the print file and dump command-line help is requested
c
      ier=<a href="../fapishort/fdds_openpr.html">fdds_openpr</a>(prog,'')
      if (ier.gt.0) call help(prog,Title)

c
c Open input file
c
      fd_in=<a href="../fapishort/fddx_in.html">fddx_in</a>('in','stdin:',Title)

c
c Retrieve data characteristics
c
      ier=<a href="../fapishort/fdds_scanf.html">fdds_scanf</a>('size.axis(1)','%d\0',n1)
      ier=<a href="../fapishort/fdds_scanf.html">fdds_scanf</a>('size.axis(2)','%d\0',n2)
      n3=<a href="../fapishort/fdds_axis_prod.html">fdds_axis_prod</a>(3)

      ier=<a href="../fapishort/fdds_scanf.html">fdds_scanf</a>('delta.axis(1)','%f\0',d1)
      ier=<a href="../fapishort/fdds_scanf.html">fdds_scanf</a>('origin.axis(1)','%f\0',o1)

c
c Retrieve other parameters needed from user
c
      call cmdln(alpha,power,eps,linv,lverb)

c
c Open the output
c
      fd_out=<a href="../fapishort/fddx_out.html">fddx_out</a>('out','stdout:',Title,fd_in)
      ier8=<a href="../fapishort/fdds_lseek8.html">fdds_lseek8</a>(fd_out,0,izero8,SEEK_SET)

c
c Allocate arrays
c
      ptr_gain=<a href="../fapishort/fdds_malloc8.html">fdds_malloc8</a>(dble(n1*SIZEOF_REAL))
      ptr_times=<a href="../fapishort/fdds_malloc8.html">fdds_malloc8</a>(dble(n1*SIZEOF_REAL))
      ptr_record=<a href="../fapishort/fdds_malloc8.html">fdds_malloc8</a>(dble(n1*n2*SIZEOF_REAL))

c
c Set up the algorithm
c
      call compute_gain(gain, times, n1,o1,d1, alpha,power,eps, linv)

c
c Loop over input data, applying the algorithm
c
      do i3 = 1,n3

         if (lverb) then
            if (mod(i3,10).eq.0) then
               ier=<a href="../fapishort/fdds_prtcon.html">fdds_prtcon</a>('Record %5d of %5d\n\0',i3,n3)
            endif
         endif

         n2_in=<a href="../fapishort/fddx_read.html">fddx_read</a>(fd_in,record,n2)
         if (n2_in.ne.n2) then
            ier=<a href="../fapishort/fdds_prterr.html">fdds_prterr</a>('Reading record %d. %d traces read\n\0',
     :                      i3,n2_in)
            ier=<a href="../fapishort/fdds_close.html">fdds_close</a>(fd_in)
            ier=<a href="../fapishort/fdds_close.html">fdds_close</a>(fd_out)
            ier=<a href="../fapishort/fdds_closepr.html">fdds_closepr</a>()
            stop
         endif

         call apply_gain(record, gain, n1, n2)

         n2_out=<a href="../fapishort/fddx_write.html">fddx_write</a>(fd_out,record,n2)
         if (n2_out.ne.n2) then
            ier=<a href="../fapishort/fdds_prterr.html">fdds_prterr</a>('Writing record %d. %d traces written\n\0',
     :                      i3,n2_out)
            ier=<a href="../fapishort/fdds_close.html">fdds_close</a>(fd_in)
            ier=<a href="../fapishort/fdds_close.html">fdds_close</a>(fd_out)
            ier=<a href="../fapishort/fdds_closepr.html">fdds_closepr</a>()
            stop
         endif

      enddo

c
c Clean up
c
      ier=<a href="../fapishort/fdds_free.html">fdds_free</a>(ptr_record)
      ier=<a href="../fapishort/fdds_free.html">fdds_free</a>(ptr_times)
      ier=<a href="../fapishort/fdds_free.html">fdds_free</a>(ptr_gain)

      ier=<a href="../fapishort/fdds_close.html">fdds_close</a>(fd_in)
      ier=<a href="../fapishort/fdds_close.html">fdds_close</a>(fd_out)
      ier=<a href="../fapishort/fdds_closepr.html">fdds_closepr</a>()

c
c Stop
c
      stop
      end




c***********************************************************************
c
c subroutine to print help when requested on the command line
c
c***********************************************************************

      subroutine help(prog,Title)

      implicit none

      character prog*(*), Title*(*)
      integer lnblnk

      write(0,*)''
      write(0,*)Title(1:lnblnk(Title))
      write(0,*)''
      write(0,*)' out_data = alpha * in_data * t**power'
      write(0,*)''
      write(0,*)' Parameter....Meaning..........................Default'
      write(0,*)''
      write(0,*)'  in=         input dictionary                  stdin:'
      write(0,*)'  out=        output dictionary                stdout:'
      write(0,*)''
      write(0,*)'  alpha=      linear scale factor                  1.0'
      write(0,*)'  power=      exponent for time scale factor       2.0'
      write(0,*)'  eps=        addend for inverse scaling to     1.0e-6'
      write(0,*)'                prevent divide by zero'
      write(0,*)''
      write(0,*)''
      write(0,*)'  inverse=    perform inverse of scaling            no'
      write(0,*)'  verbose=    verbose output                        no'
      write(0,*)''
      write(0,*)'  USAGE: '//prog(1:lnblnk(prog))
      write(0,*)'           in=[in_dict] out=[out_dict]'
      write(0,*)'           [ alpha=[alpha] power=[power] eps=[eps]'
      write(0,*)'             inverse=[y|n] verbose=[y|n] ]'
      write(0,*)''

      stop

      return
      end




c***********************************************************************
c
c Retrieve general user parameters
c
c***********************************************************************

      subroutine cmdln(alpha,power,eps,linv,lverb)

      implicit none

#include &lt;<a href="../resources/fdds.h.html">fdds.h</a>&gt;
      integer ier

      logical lverb, linv
      real    alpha,power,eps

      ier=<a href="../fapishort/fdds_dict.html">fdds_dict</a>('par:','scan')

      alpha=1.0
      ier=<a href="../fapishort/fdds_scanf.html">fdds_scanf</a>('alpha a','%f\0',alpha)

      power=2.0
      ier=<a href="../fapishort/fdds_scanf.html">fdds_scanf</a>('power exp','%f\0',power)

      eps=1.0e-6
      ier=<a href="../fapishort/fdds_scanf.html">fdds_scanf</a>('eps','%f\0',eps)

      linv=.false.
      if (<a href="../fapishort/fdds_scank.html">fdds_scank</a>('inverse',DDS_TRUE_KEY).gt.0) linv=.true.

      lverb=.false.
      if (<a href="../fapishort/fdds_scank.html">fdds_scank</a>('verbose',DDS_TRUE_KEY).gt.0) lverb=.true.

      return
      end




c***********************************************************************
c
c Build gain() curve
c
c***********************************************************************

      subroutine compute_gain
     :       (gain, times, n1, o1, d1, alpha,power,eps, linv)

      implicit none

c Arguments
      integer n1
      logical linv
      real    o1,d1, alpha,power,eps

      real    gain(n1),times(n1)

c Local loop index
      integer i1

c Initialize vector of times
      do i1 = 1, n1
         times(i1)= o1 + d1*real(i1-1)
      enddo

c Catch invalid power functions ( negative_time**non_integer )
      if (power .ne. real(int(power))) then
         do i1 = 1,n1
            times(i1)=max(0.0,times(i1))
         enddo
      endif

c Catch possible divide by zero
      if (linv) then
         do i1 = 1,n1
            if (times(i1) .eq. 0.0) then
               times(i1)=times(i1)+eps
            endif
         enddo
      endif

c Go fill the gain vector
      do i1 = 1, n1
         gain(i1) = alpha * times(i1) ** power
      enddo

c Invert as needed
      if (linv) then
         do i1 = 1,n1
            gain(i1) = 1.0/gain(i1)
         enddo
      endif

      return
      end




c***********************************************************************
c
c Apply gain() curve to traces in record()
c
c***********************************************************************

      subroutine apply_gain ( record, gain, n1, n2 )

      implicit none

      integer n1,n2
      real    record(n1,n2), gain(n1)

      integer i1,i2

      do i2 = 1,n2
         do i1 = 1,n1
            record(i1,i2) = record(i1,i2) * gain(i1)
         enddo
      enddo

      return
      end
</pre>
  
    <!*********************************************************************>
    <script type="text/javascript">footer()</script>
  </body>
</html>
